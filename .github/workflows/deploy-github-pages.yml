name: Deploy to GitHub Pages (from zip)

on:
  push:
    branches:
      - main
  workflow_dispatch:

permissions:
  contents: read
  pages: write
  id-token: write

concurrency:
  group: pages
  cancel-in-progress: true

env:
  ZIP_FILE: pokemon-roulette-source.zip

jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup Pages
        uses: actions/configure-pages@v5

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: 18

      - name: Unzip source
        run: |
          set -e
          if [ ! -f "${{ env.ZIP_FILE }}" ]; then
            echo "ERROR: zip '${{ env.ZIP_FILE }}' not found."
            ls -la *.zip || true
            exit 1
          fi
          rm -rf app
          mkdir -p app
          unzip -q "${{ env.ZIP_FILE }}" -d app

      - name: Find project root (package.json)
        run: |
          set -e
          ROOT="$(find app -maxdepth 12 -name package.json -print -quit | xargs -r dirname)"
          if [ -z "$ROOT" ]; then
            echo "ERROR: package.json not found inside zip."
            exit 1
          fi
          echo "PROJECT_ROOT=$ROOT" >> "$GITHUB_ENV"
          echo "Project root: $ROOT"

      - name: Install dependencies
        working-directory: ${{ env.PROJECT_ROOT }}
        run: npm install --legacy-peer-deps

      - name: Install @angular/localize (match Angular version)
        working-directory: ${{ env.PROJECT_ROOT }}
        run: |
          set -e
          CORE_VER=$(node -p "require('./package.json').dependencies?.['@angular/core'] || require('./package.json').devDependencies?.['@angular/core'] || ''")
          if [ -z "$CORE_VER" ]; then
            echo "ERROR: Could not detect @angular/core version from package.json"
            exit 1
          fi
          CORE_VER="${CORE_VER#^}"
          CORE_VER="${CORE_VER#~}"
          npm install "@angular/localize@$CORE_VER" --legacy-peer-deps

      - name: Patch (wheel sharper/bigger + Mega animation+SFX+cry + Gen 9 trainers)
        working-directory: ${{ env.PROJECT_ROOT }}
        run: |
          set -e

          # ---- Gen 9 trainer sprites (bundle locally) ----
          mkdir -p src/assets/trainers
          curl -L --retry 3 --fail "https://archives.bulbagarden.net/media/upload/6/62/Spr_Masters_Florian_2.png" -o "src/assets/trainers/Spr_Masters_Florian_2.png"
          curl -L --retry 3 --fail "https://archives.bulbagarden.net/media/upload/4/4a/Spr_Masters_Juliana.png" -o "src/assets/trainers/Spr_Masters_Juliana.png"

          python3 - <<'PY'
          from pathlib import Path
          import re

          def read(p: Path) -> str:
              return p.read_text(encoding="utf-8")

          def write(p: Path, s: str) -> None:
              p.parent.mkdir(parents=True, exist_ok=True)
              p.write_text(s, encoding="utf-8")

          # ----------------------------
          # Gen 9 trainer sprites: use local assets
          # ----------------------------
          trainer = Path("src/app/services/trainer-service/trainer-sprite-data.ts")
          if trainer.exists():
              t = read(trainer)
              t = t.replace(
                  "https://archives.bulbagarden.net/media/upload/6/62/Spr_Masters_Florian_2.png",
                  "assets/trainers/Spr_Masters_Florian_2.png",
              )
              t = t.replace(
                  "https://archives.bulbagarden.net/media/upload/4/4a/Spr_Masters_Juliana.png",
                  "assets/trainers/Spr_Masters_Juliana.png",
              )
              write(trainer, t)

          # ----------------------------
          # Wheel: bigger on mobile + HiDPI sharp + pointer stable
          # ----------------------------
          wheel_ts = Path("src/app/wheel/wheel.component.ts")
          wheel_html = Path("src/app/wheel/wheel.component.html")
          wheel_css = Path("src/app/wheel/wheel.component.css")

          if wheel_ts.exists():
              w = read(wheel_ts)

              # Bigger wheel on mobile (keep desktop close to original)
              w = re.sub(
                  r"this\.canvasHeight\s*=\s*Math\.min\(window\.innerHeight,\s*window\.innerWidth\)\s*\*\s*0\.50\s*;",
                  "const minDim = Math.min(window.innerHeight, window.innerWidth);\n"
                  "    const isMobile = window.innerWidth <= 768;\n"
                  "    this.canvasHeight = minDim * (isMobile ? 0.78 : 0.55);",
                  w,
                  count=1,
              )
              w = re.sub(
                  r"this\.cursorWidth\s*=\s*40\s*;",
                  "this.cursorWidth = (window.innerWidth <= 768) ? 48 : 40;",
                  w,
                  count=1,
              )

              # Add HiDPI setup method if missing
              if "setupHiDpiCanvases(" not in w:
                  method = """

            private setupHiDpiCanvases(): void {
              const dpr = window.devicePixelRatio || 1;

              // Wheel canvas: internal pixels = css * dpr
              this.wheelCanvas.width = Math.floor(this.wheelWidth * dpr);
              this.wheelCanvas.height = Math.floor(this.canvasHeight * dpr);
              this.wheelCanvas.style.width = `${this.wheelWidth}px`;
              this.wheelCanvas.style.height = `${this.canvasHeight}px`;
              this.wheelCtx.setTransform(dpr, 0, 0, dpr, 0, 0);

              // Pointer canvas
              this.pointerCanvas.width = Math.floor(this.cursorWidth * dpr);
              this.pointerCanvas.height = Math.floor(this.canvasHeight * dpr);
              this.pointerCanvas.style.width = `${this.cursorWidth}px`;
              this.pointerCanvas.style.height = `${this.canvasHeight}px`;
              this.pointerCtx.setTransform(dpr, 0, 0, dpr, 0, 0);
            }
"""
                  w = w.rsplit("}", 1)[0] + method + "\n}\n"

              # Call HiDPI setup once contexts exist
              w = w.replace(
                  "this.pointerCtx = this.pointerCanvas.getContext('2d')!;",
                  "this.pointerCtx = this.pointerCanvas.getContext('2d')!;\n\n    this.setupHiDpiCanvases();",
                  1,
              )

              # Draw wheel in CSS pixels (ctx is scaled)
              w = w.replace("const centerX = this.wheelCanvas.width / 2;", "const centerX = this.wheelWidth / 2;")
              w = w.replace("const centerY = this.wheelCanvas.height / 2;", "const centerY = this.canvasHeight / 2;")
              w = w.replace("const radius = (this.wheelCanvas.width / 2);", "const radius = (this.wheelWidth / 2);")
              w = w.replace(
                  "this.wheelCtx.clearRect(0, 0, this.wheelCanvas.width, this.wheelCanvas.height);",
                  "this.wheelCtx.clearRect(0, 0, this.wheelWidth, this.canvasHeight);",
              )

              # Replace drawPointer with a stable+clearing version
              w = re.sub(
                  r"drawPointer\(\): void \{[\s\S]*?\n\s*\}",
                  """drawPointer(): void {
              const midY = this.canvasHeight / 2;
              const xRight = this.cursorWidth - 2;
              const tipX = 2;

              this.pointerCtx.save();
              this.pointerCtx.clearRect(0, 0, this.cursorWidth, this.canvasHeight);
              this.pointerCtx.lineWidth = 2;
              this.pointerCtx.strokeStyle = this.pointerStrokeColor;
              this.pointerCtx.fillStyle = this.pointerFillColor;
              this.pointerCtx.beginPath();
              this.pointerCtx.moveTo(xRight, midY - 20);
              this.pointerCtx.lineTo(xRight, midY + 20);
              this.pointerCtx.lineTo(tipX, midY);
              this.pointerCtx.closePath();
              this.pointerCtx.stroke();
              this.pointerCtx.fill();
              this.pointerCtx.restore();
            }""",
                  w,
                  count=1,
              )

              write(wheel_ts, w)

          if wheel_html.exists():
              h = read(wheel_html)
              h = h.replace('[width]="wheelWidth"', '[style.width.px]="wheelWidth"')
              h = h.replace('[height]="canvasHeight"', '[style.height.px]="canvasHeight"')
              h = h.replace('[width]="cursorWidth"', '[style.width.px]="cursorWidth"')
              h = h.replace('[height]="canvasHeight"', '[style.height.px]="canvasHeight"')
              write(wheel_html, h)

          if wheel_css.exists():
              write(
                  wheel_css,
                  ".wheel-container{display:flex;flex-direction:column;align-items:center;width:100%}\n"
                  ".wheel-container p{font-size:clamp(1.05rem,4.6vw,1.5rem);font-weight:700;text-align:center;"
                  "max-width:min(92vw,520px);padding:0 .75rem;line-height:1.2;overflow-wrap:anywhere;word-break:break-word;"
                  "margin:.5rem 0 0}\n"
                  ".canvas-container{display:flex;flex-direction:row;align-items:center;justify-content:center;margin-left:0;width:100%}\n"
                  "#wheel{touch-action:manipulation}\n"
              )

          # ----------------------------
          # Mega evolution roulette: animation + mega SFX + Showdown cry
          # ----------------------------
          mega_dir = Path("src/app/main-game/roulette-container/roulettes/mega-evolution-roulette")
          mega_ts = mega_dir / "mega-evolution-roulette.component.ts"
          mega_html = mega_dir / "mega-evolution-roulette.component.html"
          mega_css = mega_dir / "mega-evolution-roulette.component.css"

          if mega_ts.exists():
              write(mega_ts, r'''import { Component, EventEmitter, OnDestroy, OnInit, Output, TemplateRef, ViewChild } from '@angular/core';
          import { NgIf } from '@angular/common';
          import { TranslatePipe } from '@ngx-translate/core';
          import { NgbModal, NgbModalRef } from '@ng-bootstrap/ng-bootstrap';
          import { Subscription } from 'rxjs';

          import { PokemonItem } from '../../../../interfaces/pokemon-item';
          import { MegaEvolutionService, MegaForm } from '../../../../services/mega-evolution-service/mega-evolution.service';
          import { GameStateService } from '../../../../services/game-state-service/game-state.service';
          import { WheelComponent } from '../../../../wheel/wheel.component';

          @Component({
            selector: 'app-mega-evolution-roulette',
            imports: [WheelComponent, TranslatePipe, NgIf],
            templateUrl: './mega-evolution-roulette.component.html',
            styleUrl: './mega-evolution-roulette.component.css'
          })
          export class MegaEvolutionRouletteComponent implements OnInit, OnDestroy {
            @Output() megaEvolutionFinished = new EventEmitter<void>();
            @ViewChild('megaPopup', { static: true }) megaPopup!: TemplateRef<any>;

            pokemons: PokemonItem[] = [];
            wheelItems: { text: string; weight: number; color: string }[] = [];
            isLoading = true;
            hasAvailableMegaEvolutions = false;

            popupTitle = 'megaEvolution.popupTitle';
            popupMessage = 'megaEvolution.popupMessage';

            popupBeforePokemon?: PokemonItem;
            popupBeforeName = '';
            popupBeforeSpriteUrl = '';

            popupAfterName = '';
            popupAfterSpriteUrl = '';
            popupAfterApiName = '';

            // Animation + VFX
            isMegaAnimating = false;
            typeClass = 'type-normal';

            // Audio
            private timers: number[] = [];
            private cryAudio?: HTMLAudioElement;
            private audioCtx?: AudioContext;

            private subs = new Subscription();
            private modalRef?: NgbModalRef;

            constructor(
              private megaEvolutionService: MegaEvolutionService,
              private gameStateService: GameStateService,
              private modalService: NgbModal
            ) {}

            ngOnInit(): void {
              const sub = this.gameStateService.gameState$.subscribe(async (state) => {
                this.pokemons = state.pokemons.filter((p) => p.isCaught);
                await this.buildWheelItemsAndAvailability();
                this.isLoading = false;
              });

              this.subs.add(sub);
            }

            ngOnDestroy(): void {
              this.subs.unsubscribe();
              this.stopCry();
              this.clearTimers();
              try { this.modalRef?.close(); } catch {}
              try { this.audioCtx?.close(); } catch {}
            }

            async buildWheelItemsAndAvailability(): Promise<void> {
              this.hasAvailableMegaEvolutions = false;

              for (const pokemon of this.pokemons) {
                const sub = this.megaEvolutionService.getMegaFormsForPokemon(pokemon).subscribe((forms) => {
                  if (forms.length > 0) {
                    this.hasAvailableMegaEvolutions = true;
                  }
                  this.wheelItems.push({
                    text: pokemon.text,
                    weight: 1,
                    color: '#f2f2f2'
                  });
                });

                this.subs.add(sub);
              }
            }

            onPokemonSelected(winningNumber: number): void {
              const pokemon = this.pokemons[winningNumber - 1];
              if (!pokemon) return;

              const sub = this.megaEvolutionService.getMegaFormsForPokemon(pokemon).subscribe((megaForms: MegaForm[]) => {
                if (!megaForms?.length) {
                  this.megaEvolutionFinished.emit();
                  return;
                }
                const megaForm = megaForms[Math.floor(Math.random() * megaForms.length)];
                this.applyMegaEvolution(pokemon, megaForm);
              });

              this.subs.add(sub);
            }

            private applyMegaEvolution(pokemon: PokemonItem, megaForm: MegaForm): void {
              // Snapshot BEFORE (megaEvolveForBattle mutates the same object)
              this.popupBeforePokemon = {
                ...pokemon,
                sprite: pokemon.sprite ? { ...pokemon.sprite } : pokemon.sprite
              } as PokemonItem;

              this.popupBeforeName = this.popupBeforePokemon.text;
              this.popupBeforeSpriteUrl = this.popupBeforePokemon.shiny
                ? (this.popupBeforePokemon.sprite?.front_shiny || this.popupBeforePokemon.sprite?.front_default || '')
                : (this.popupBeforePokemon.sprite?.front_default || '');

              this.popupAfterName = megaForm.displayName;
              this.popupAfterApiName = megaForm.apiName;

              const sub = this.megaEvolutionService.megaEvolveForBattle(pokemon, megaForm).subscribe({
                next: () => {
                  this.popupAfterSpriteUrl = pokemon.shiny
                    ? (pokemon.sprite?.front_shiny || pokemon.sprite?.front_default || '')
                    : (pokemon.sprite?.front_default || '');

                  const primaryType = (pokemon.types?.[0] || 'Normal').toLowerCase();
                  this.typeClass = `type-${primaryType}`;

                  this.openMegaPopupAndProceed();
                },
                error: () => this.megaEvolutionFinished.emit()
              });

              this.subs.add(sub);
            }

            private openMegaPopupAndProceed(): void {
              this.modalRef = this.modalService.open(this.megaPopup, {
                centered: true,
                backdrop: 'static',
                keyboard: false
              });

              this.isMegaAnimating = true;
              this.playMegaEvolutionSfx();

              this.timers.push(window.setTimeout(() => {
                this.playCryForMega(this.popupAfterApiName, this.popupAfterName);
              }, 900));

              this.timers.push(window.setTimeout(() => {
                try { this.modalRef?.close(); } catch {}
              }, 2200));

              this.modalRef.result.then(
                () => this.megaEvolutionFinished.emit(),
                () => this.megaEvolutionFinished.emit()
              ).finally(() => {
                this.isMegaAnimating = false;
                this.stopCry();
                this.clearTimers();
              });
            }

            private playMegaEvolutionSfx(): void {
              try {
                if (!this.audioCtx) {
                  this.audioCtx = new (window.AudioContext || (window as any).webkitAudioContext)();
                }
                const ctx = this.audioCtx;
                if (ctx.state === 'suspended') ctx.resume().catch(() => {});
                const now = ctx.currentTime;

                const osc = ctx.createOscillator();
                osc.type = 'sawtooth';
                osc.frequency.setValueAtTime(220, now);
                osc.frequency.exponentialRampToValueAtTime(1200, now + 0.55);

                const gain = ctx.createGain();
                gain.gain.setValueAtTime(0.0001, now);
                gain.gain.exponentialRampToValueAtTime(0.16, now + 0.08);
                gain.gain.exponentialRampToValueAtTime(0.0001, now + 0.75);

                const bufferSize = Math.floor(ctx.sampleRate * 0.5);
                const noiseBuffer = ctx.createBuffer(1, bufferSize, ctx.sampleRate);
                const out = noiseBuffer.getChannelData(0);
                for (let i = 0; i < bufferSize; i++) out[i] = (Math.random() * 2 - 1) * (1 - i / bufferSize);

                const noise = ctx.createBufferSource();
                noise.buffer = noiseBuffer;

                const bandpass = ctx.createBiquadFilter();
                bandpass.type = 'bandpass';
                bandpass.frequency.setValueAtTime(800, now);
                bandpass.frequency.linearRampToValueAtTime(1400, now + 0.4);

                const noiseGain = ctx.createGain();
                noiseGain.gain.setValueAtTime(0.0001, now);
                noiseGain.gain.exponentialRampToValueAtTime(0.12, now + 0.08);
                noiseGain.gain.exponentialRampToValueAtTime(0.0001, now + 0.55);

                osc.connect(gain);
                noise.connect(bandpass);
                bandpass.connect(noiseGain);

                gain.connect(ctx.destination);
                noiseGain.connect(ctx.destination);

                osc.start(now);
                noise.start(now);

                osc.stop(now + 0.8);
                noise.stop(now + 0.6);
              } catch {}
            }

            private playCryForMega(apiName: string, fallbackName: string): void {
              const id = this.toShowdownCryId(apiName || fallbackName);
              const url = `https://play.pokemonshowdown.com/audio/cries/${id}.mp3`;

              this.stopCry();

              const audio = new Audio();
              audio.preload = 'auto';
              audio.src = url;
              audio.volume = 0.9;

              audio.onerror = () => {
                const base = id.split('-mega')[0];
                if (base && base !== id) {
                  audio.src = `https://play.pokemonshowdown.com/audio/cries/${base}.mp3`;
                  audio.play().catch(() => {});
                }
              };

              audio.play().catch(() => {});
              this.cryAudio = audio;
            }

            private stopCry(): void {
              if (this.cryAudio) {
                try {
                  this.cryAudio.pause();
                  this.cryAudio.currentTime = 0;
                } catch {}
              }
              this.cryAudio = undefined;
            }

            private clearTimers(): void {
              this.timers.forEach((t) => clearTimeout(t));
              this.timers = [];
            }

            private toShowdownCryId(nameOrApi: string): string {
              let s = (nameOrApi || '').trim().toLowerCase();
              s = s.replace(/\s+/g, '-');
              s = s.replace(/[^a-z0-9\-]/g, '');
              s = s.replace(/-mega-x\b/g, '-megax').replace(/-mega-y\b/g, '-megay');
              return s;
            }
          }
          ''')

          if mega_html.exists():
              write(mega_html, r'''<div *ngIf="isLoading" class="loading">
            <p>{{ 'loading' | translate }}</p>
          </div>

          <div *ngIf="!isLoading && !hasAvailableMegaEvolutions" class="subtitle">
            <p>{{ 'megaEvolution.noAvailableMegaEvolutions' | translate }}</p>
          </div>

          <div *ngIf="!isLoading && hasAvailableMegaEvolutions">
            <app-wheel
              [items]="wheelItems"
              (selectedItemEvent)="onPokemonSelected($event)">
            </app-wheel>
          </div>

          <ng-template #megaPopup let-modal>
            <div class="modal-header">
              <h4 class="modal-title popup-title">{{ popupTitle | translate }}</h4>
            </div>

            <div class="modal-body">
              <p class="subtitle">{{ popupMessage | translate }}</p>

              <div [attr.class]="'evo-wrap ' + typeClass + (isMegaAnimating ? ' animating' : '')">
                <div class="particles" aria-hidden="true"></div>

                <div class="evolution-stage">
                  <img class="sprite sprite-before" [src]="popupBeforeSpriteUrl" [alt]="popupBeforeName" />
                  <img class="sprite sprite-after" [src]="popupAfterSpriteUrl" [alt]="popupAfterName" />
                </div>

                <div class="name-row">
                  <div class="name">{{ popupBeforeName }}</div>
                  <div class="arrow" aria-hidden="true">â†’</div>
                  <div class="name">{{ popupAfterName }}</div>
                </div>
              </div>

              <div class="actions">
                <button class="btn btn-dark" (click)="modal.close()">{{ 'ok' | translate }}</button>
              </div>
            </div>
          </ng-template>
          ''')

          if mega_css.exists():
              write(mega_css, r'''.loading{text-align:center;margin-top:1rem}
          .subtitle{text-align:center;opacity:.9;margin-bottom:.75rem}
          .popup-title{text-align:center;margin-bottom:0}
          .actions{display:flex;justify-content:center;margin-top:1rem}

          .evo-wrap{display:flex;flex-direction:column;align-items:center;gap:.75rem;position:relative}
          .evolution-stage{position:relative;width:11rem;height:11rem;display:flex;align-items:center;justify-content:center}
          .sprite{position:absolute;width:11rem;height:11rem;object-fit:contain;will-change:transform,opacity,filter}
          .sprite-after{opacity:0;transform:scale(.92);filter:brightness(1.2) drop-shadow(0 0 .35rem rgba(255,255,255,.35))}

          .name-row{display:flex;align-items:center;justify-content:center;gap:.75rem;flex-wrap:wrap}
          .name{min-width:6.5rem;text-align:center;font-weight:700}
          .arrow{font-size:1.6rem;opacity:.85}

          .particles{position:absolute;inset:-10%;pointer-events:none;overflow:hidden;border-radius:999px}
          .particles::before{content:'';position:absolute;inset:0;opacity:0;transform:translateY(15%);will-change:transform,opacity,filter}

          .animating .sprite-before{animation:megaBefore .85s ease-in-out forwards}
          .animating .sprite-after{animation:megaAfter .85s ease-in-out forwards}
          .animating .particles::before{opacity:1;animation:particleMove .9s ease-out forwards}

          @keyframes megaBefore{
            0%{opacity:1;transform:scale(1);filter:brightness(1)}
            45%{opacity:1;transform:scale(1.02);filter:brightness(1.7)}
            100%{opacity:0;transform:scale(1.1);filter:brightness(1.2) blur(2px)}
          }
          @keyframes megaAfter{
            0%{opacity:0;transform:scale(.92);filter:brightness(2.2) blur(2px)}
            60%{opacity:1;transform:scale(1.06);filter:brightness(1.25)}
            100%{opacity:1;transform:scale(1);filter:brightness(1.05)}
          }
          @keyframes particleMove{
            from{transform:translateY(18%) scale(.98);filter:blur(0)}
            to{transform:translateY(-20%) scale(1.02);filter:blur(.4px)}
          }

          .type-water .particles::before{
            background-image:
              radial-gradient(circle at 15% 80%, rgba(200,240,255,.95) 0 2px, transparent 3px),
              radial-gradient(circle at 45% 90%, rgba(200,240,255,.95) 0 3px, transparent 4px),
              radial-gradient(circle at 75% 85%, rgba(200,240,255,.95) 0 2px, transparent 3px);
            background-size:24px 24px;
          }
          .type-fire .particles::before{
            background-image:
              radial-gradient(circle at 20% 80%, rgba(255,190,120,.95) 0 2px, transparent 3px),
              radial-gradient(circle at 55% 90%, rgba(255,150,90,.9) 0 3px, transparent 4px),
              radial-gradient(circle at 80% 85%, rgba(255,210,140,.9) 0 2px, transparent 3px);
            background-size:22px 22px;
          }
          .type-electric .particles::before{
            background-image:
              linear-gradient(135deg, transparent 45%, rgba(255,255,160,.85) 46%, rgba(255,255,160,.85) 54%, transparent 55%),
              linear-gradient(45deg, transparent 45%, rgba(255,255,160,.75) 46%, rgba(255,255,160,.75) 54%, transparent 55%);
            background-size:28px 28px;
            mix-blend-mode:screen;
          }
          .type-grass .particles::before{
            background-image:
              radial-gradient(circle at 25% 85%, rgba(170,255,180,.85) 0 2px, transparent 3px),
              radial-gradient(circle at 60% 90%, rgba(170,255,180,.8) 0 3px, transparent 4px),
              radial-gradient(circle at 80% 75%, rgba(170,255,180,.75) 0 2px, transparent 3px);
            background-size:26px 26px;
          }
          .type-normal .particles::before{
            background-image:
              radial-gradient(circle at 25% 85%, rgba(255,255,255,.5) 0 2px, transparent 3px),
              radial-gradient(circle at 60% 90%, rgba(255,255,255,.45) 0 3px, transparent 4px);
            background-size:26px 26px;
          }
          ''')
          PY

      - name: Build (relative paths for GitHub Pages)
        working-directory: ${{ env.PROJECT_ROOT }}
        env:
          NODE_OPTIONS: --max_old_space_size=4096
        run: npm run build -- --configuration production --base-href "./" --deploy-url "./"

      - name: Locate index.html for Pages
        run: |
          set -e
          IDX="$(find "${{ env.PROJECT_ROOT }}/dist" -maxdepth 12 -type f -name index.html -print -quit)"
          if [ -z "$IDX" ]; then
            echo "ERROR: index.html not found in dist."
            exit 1
          fi
          PAGES_DIR="$(dirname "$IDX")"
          echo "PAGES_PATH=$PAGES_DIR" >> "$GITHUB_ENV"
          touch "$PAGES_DIR/.nojekyll"

      - name: Upload Pages artifact
        uses: actions/upload-pages-artifact@v3
        with:
          path: ${{ env.PAGES_PATH }}

  deploy:
    needs: build
    runs-on: ubuntu-latest
    environment:
      name: github-pages
      url: ${{ steps.deployment.outputs.page_url }}
    steps:
      - name: Deploy to GitHub Pages
        id: deployment
        uses: actions/deploy-pages@v4
