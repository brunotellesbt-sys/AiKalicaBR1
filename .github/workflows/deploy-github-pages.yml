name: Deploy to GitHub Pages (from zip)

on:
  push:
    branches:
      - main
  workflow_dispatch:

permissions:
  contents: read
  pages: write
  id-token: write

concurrency:
  group: pages
  cancel-in-progress: true

env:
  ZIP_FILE: pokemon-roulette-source.zip

jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup Pages
        uses: actions/configure-pages@v5

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: 18

      - name: Unzip source
        run: |
          set -e
          if [ ! -f "${{ env.ZIP_FILE }}" ]; then
            echo "ERROR: zip '${{ env.ZIP_FILE }}' not found."
            ls -la *.zip || true
            exit 1
          fi
          rm -rf app
          mkdir -p app
          unzip -q "${{ env.ZIP_FILE }}" -d app
          ls -la app

      - name: Find project root (package.json)
        run: |
          set -e
          ROOT="$(find app -maxdepth 12 -name package.json -print -quit | xargs -r dirname)"
          if [ -z "$ROOT" ]; then
            echo "ERROR: package.json not found inside zip."
            exit 1
          fi
          echo "PROJECT_ROOT=$ROOT" >> $GITHUB_ENV
          ls -la "$ROOT"

      - name: Install dependencies
        working-directory: ${{ env.PROJECT_ROOT }}
        run: npm install --legacy-peer-deps

      - name: Install @angular/localize (match Angular version)
        working-directory: ${{ env.PROJECT_ROOT }}
        run: |
          set -e
          CORE_VER=$(node -p "require('./package.json').dependencies?.['@angular/core'] || require('./package.json').devDependencies?.['@angular/core'] || ''")
          if [ -z "$CORE_VER" ]; then
            echo "ERROR: Could not detect @angular/core version from package.json"
            exit 1
          fi
          CORE_VER="${CORE_VER#^}"
          CORE_VER="${CORE_VER#~}"
          npm install @angular/localize@$CORE_VER --legacy-peer-deps

      - name: Patch (wheel bigger & sharper + mega evo animation & cries + Gen 9 trainers)
        working-directory: ${{ env.PROJECT_ROOT }}
        run: |
          set -e

          # --- Gen 9 trainer sprites: bundle locally (no hotlink) ---
          mkdir -p src/assets/trainers
          curl -L --retry 3 --fail "https://archives.bulbagarden.net/media/upload/6/62/Spr_Masters_Florian_2.png" -o "src/assets/trainers/Spr_Masters_Florian_2.png"
          curl -L --retry 3 --fail "https://archives.bulbagarden.net/media/upload/4/4a/Spr_Masters_Juliana.png" -o "src/assets/trainers/Spr_Masters_Juliana.png"

          python3 - <<'PY'
          import re
          import textwrap
          from pathlib import Path

          # ----------------------------
          # Trainer sprites (Gen 9)
          # ----------------------------
          trainer = Path("src/app/services/trainer-service/trainer-sprite-data.ts")
          if trainer.exists():
              txt = trainer.read_text(encoding="utf-8")
              txt = txt.replace(
                  "https://archives.bulbagarden.net/media/upload/6/62/Spr_Masters_Florian_2.png",
                  "assets/trainers/Spr_Masters_Florian_2.png"
              )
              txt = txt.replace(
                  "https://archives.bulbagarden.net/media/upload/4/4a/Spr_Masters_Juliana.png",
                  "assets/trainers/Spr_Masters_Juliana.png"
              )
              trainer.write_text(txt, encoding="utf-8")

          # ----------------------------
          # Wheel: bigger on mobile + HiDPI sharp + pointer back
          # ----------------------------
          wheel_ts = Path("src/app/wheel/wheel.component.ts")
          if wheel_ts.exists():
              w = wheel_ts.read_text(encoding="utf-8")

              w = w.replace(
                  "import { AfterViewInit, Component, EventEmitter, Input, OnChanges, Output, SimpleChanges } from '@angular/core';",
                  "import { AfterViewInit, Component, EventEmitter, Input, OnChanges, Output, SimpleChanges, OnDestroy } from '@angular/core';"
              )

              w = w.replace(
                  "export class WheelComponent implements AfterViewInit, OnChanges {",
                  "export class WheelComponent implements AfterViewInit, OnChanges, OnDestroy {"
              )

              w = re.sub(
                  r"this\.canvasHeight\s*=\s*Math\.min\(window\.innerHeight,\s*window\.innerWidth\)\s*\*\s*0\.50\s*;\s*"
                  r"this\.wheelWidth\s*=\s*this\.canvasHeight\s*;\s*"
                  r"this\.cursorWidth\s*=\s*40\s*;\s*"
                  r"this\.fontSize\s*=\s*this\.wheelWidth\s*/\s*24\s*;",
                  "this.updateDimensions();",
                  w,
                  count=1
              )

              anchor = "  private translatedItems: WheelItem[] = [];\n"
              if anchor in w and "resizeListener" not in w:
                  w = w.replace(
                      anchor,
                      anchor +
                      "\n  private readonly resizeListener = () => {\n"
                      "    this.updateDimensions();\n"
                      "    this.setupHiDpiCanvases();\n"
                      "    this.drawWheel(this.spinning ? this.currentRotation : 0);\n"
                      "    this.drawPointer();\n"
                      "  };\n"
                  )

              marker = "    this.pointerCtx = this.pointerCanvas.getContext('2d')!;"
              if marker in w and "window.addEventListener('resize', this.resizeListener" not in w:
                  w = w.replace(
                      marker,
                      marker +
                      "\n    this.setupHiDpiCanvases();\n"
                      "    window.addEventListener('resize', this.resizeListener, { passive: true });",
                      1
                  )

              w = w.replace("    const centerX = this.wheelCanvas.width / 2;", "    const centerX = this.wheelWidth / 2;")
              w = w.replace("    const centerY = this.wheelCanvas.height / 2;", "    const centerY = this.canvasHeight / 2;")
              w = w.replace("    const radius = (this.wheelCanvas.width / 2);", "    const radius = (this.wheelWidth / 2);")
              w = w.replace(
                  "    this.wheelCtx.clearRect(0, 0, this.wheelCanvas.width, this.wheelCanvas.height);",
                  "    this.wheelCtx.clearRect(0, 0, this.wheelWidth, this.canvasHeight);"
              )

              w = re.sub(
                  r"drawPointer\(\): void \{[\s\S]*?\n\s*\}",
                  "drawPointer(): void {\n"
                  "    const midY = this.canvasHeight / 2;\n"
                  "    const xRight = this.cursorWidth - 2;\n"
                  "    const tipX = 2;\n\n"
                  "    this.pointerCtx.save();\n"
                  "    this.pointerCtx.clearRect(0, 0, this.cursorWidth, this.canvasHeight);\n"
                  "    this.pointerCtx.lineWidth = 2;\n"
                  "    this.pointerCtx.strokeStyle = this.pointerStrokeColor;\n"
                  "    this.pointerCtx.fillStyle = this.pointerFillColor;\n"
                  "    this.pointerCtx.beginPath();\n"
                  "    this.pointerCtx.moveTo(xRight, midY - 20);\n"
                  "    this.pointerCtx.lineTo(xRight, midY + 20);\n"
                  "    this.pointerCtx.lineTo(tipX, midY);\n"
                  "    this.pointerCtx.closePath();\n"
                  "    this.pointerCtx.stroke();\n"
                  "    this.pointerCtx.fill();\n"
                  "    this.pointerCtx.restore();\n"
                  "  }",
                  w,
                  count=1
              )

              if not re.search(r"\bprivate\s+updateDimensions\(", w):
                  add = """
            private updateDimensions(): void {
              const minDim = Math.min(window.innerHeight, window.innerWidth);
              const isMobile = window.innerWidth <= 768;

              this.canvasHeight = Math.round(minDim * (isMobile ? 0.78 : 0.55));
              this.wheelWidth = this.canvasHeight;
              this.cursorWidth = isMobile ? 48 : 40;
              this.fontSize = this.wheelWidth / 24;
            }

            private setupHiDpiCanvases(): void {
              const dpr = window.devicePixelRatio || 1;

              this.wheelCanvas.width = Math.floor(this.wheelWidth * dpr);
              this.wheelCanvas.height = Math.floor(this.canvasHeight * dpr);
              this.wheelCanvas.style.width = `${this.wheelWidth}px`;
              this.wheelCanvas.style.height = `${this.canvasHeight}px`;
              this.wheelCtx.setTransform(dpr, 0, 0, dpr, 0, 0);

              this.pointerCanvas.width = Math.floor(this.cursorWidth * dpr);
              this.pointerCanvas.height = Math.floor(this.canvasHeight * dpr);
              this.pointerCanvas.style.width = `${this.cursorWidth}px`;
              this.pointerCanvas.style.height = `${this.canvasHeight}px`;
              this.pointerCtx.setTransform(dpr, 0, 0, dpr, 0, 0);
            }

            ngOnDestroy(): void {
              window.removeEventListener('resize', this.resizeListener as any);
            }
          """
                  last = w.rfind("}")
                  if last != -1:
                      w = w[:last] + add + "\n" + w[last:]

              wheel_ts.write_text(w, encoding="utf-8")

          wheel_css = Path("src/app/wheel/wheel.component.css")
          if wheel_css.exists():
              wheel_css.write_text(
                  ".wheel-container{display:flex;flex-direction:column;align-items:center;width:100%}\n"
                  ".wheel-container p{font-size:clamp(1.05rem,4.6vw,1.5rem);font-weight:700;text-align:center;"
                  "max-width:min(92vw,520px);padding:0 .75rem;line-height:1.2;overflow-wrap:anywhere;word-break:break-word;"
                  "margin:.5rem 0 0}\n"
                  ".canvas-container{display:flex;flex-direction:row;align-items:center;justify-content:center;margin-left:0;width:100%}\n"
                  "#wheel{touch-action:manipulation}\n",
                  encoding="utf-8"
              )

          # ----------------------------
          # Mega Evolution roulette (write full TS/HTML/CSS safely)
          # ----------------------------
          mega_ts = Path("src/app/main-game/roulette-container/roulettes/mega-evolution-roulette/mega-evolution-roulette.component.ts")
          mega_html = Path("src/app/main-game/roulette-container/roulettes/mega-evolution-roulette/mega-evolution-roulette.component.html")
          mega_css = Path("src/app/main-game/roulette-container/roulettes/mega-evolution-roulette/mega-evolution-roulette.component.css")

          if mega_ts.exists():
              ts_src = textwrap.dedent("""\
                  import { Component, EventEmitter, OnDestroy, OnInit, Output, TemplateRef, ViewChild } from '@angular/core';
                  import { NgIf, NgClass } from '@angular/common';
                  import { map, Subscription, forkJoin } from 'rxjs';
                  import { TranslatePipe } from '@ngx-translate/core';
                  import { NgbModal, NgbModalRef } from '@ng-bootstrap/ng-bootstrap';

                  import { WheelComponent } from '../../../../wheel/wheel.component';
                  import { PokemonItem } from '../../../../interfaces/pokemon-item';
                  import { MegaEvolutionService, MegaForm } from '../../../../services/mega-evolution-service/mega-evolution.service';
                  import { GameStateService } from '../../../../services/game-state-service/game-state.service';
                  import { PokemonService } from '../../../../services/pokemon-service/pokemon.service';
                  import { GameModeService } from '../../../../services/game-mode/game-mode.service';

                  type ShowdownPokedexEntry = { types?: string[] };

                  @Component({
                    selector: 'app-mega-evolution-roulette',
                    standalone: true,
                    imports: [WheelComponent, TranslatePipe, NgIf, NgClass],
                    templateUrl: './mega-evolution-roulette.component.html',
                    styleUrls: ['./mega-evolution-roulette.component.css']
                  })
                  export class MegaEvolutionRouletteComponent implements OnInit, OnDestroy {
                    @Output() megaEvolutionEvent = new EventEmitter<PokemonItem[]>();
                    @ViewChild('megaPopup', { static: true }) megaPopup!: TemplateRef<any>;

                    pokemons: PokemonItem[] = [];
                    wheelItems: { text: string; weight: number; color: string }[] = [];

                    isLoading = true;
                    hasAvailableMegaEvolutions = false;

                    private subscriptions: Subscription[] = [];
                    private modalRef?: NgbModalRef;

                    popupTitle = 'megaEvolution.popupTitle';
                    popupMessage = '';

                    popupBeforeName = '';
                    popupAfterName = '';
                    popupBeforeSpriteUrl = '';
                    popupAfterSpriteUrl = '';
                    popupAfterApiName = '';

                    isMegaAnimating = false;
                    typeClass = 'type-normal';

                    private audioCtx?: AudioContext;
                    private cryAudio?: HTMLAudioElement;
                    private timers: number[] = [];

                    private static showdownDexPromise: Promise<Record<string, ShowdownPokedexEntry>> | null = null;

                    constructor(
                      private megaEvolutionService: MegaEvolutionService,
                      private gameStateService: GameStateService,
                      private pokemonService: PokemonService,
                      private gameModeService: GameModeService,
                      private modalService: NgbModal
                    ) {}

                    ngOnInit(): void {
                      const sub = this.gameStateService.pokemons$
                        .pipe(map(p => p.filter(pk => pk.isCaught)))
                        .subscribe(async (caughtPokemons) => {
                          this.pokemons = caughtPokemons;
                          await this.buildWheelItemsAndAvailability(caughtPokemons);
                          this.isLoading = false;
                        });

                      this.subscriptions.push(sub);
                    }

                    ngOnDestroy(): void {
                      this.subscriptions.forEach(s => s.unsubscribe());
                      this.cleanupAudio();
                      this.clearTimers();
                      if (this.modalRef) {
                        try { this.modalRef.close(); } catch {}
                      }
                    }

                    private async buildWheelItemsAndAvailability(pokemons: PokemonItem[]): Promise<void> {
                      this.hasAvailableMegaEvolutions = false;

                      if (!pokemons?.length) {
                        this.wheelItems = [];
                        return;
                      }

                      const checks$ = pokemons.map(pokemon =>
                        this.megaEvolutionService.getAvailableMegaFormsForPokemon(pokemon).pipe(
                          map((forms) => ({ pokemon, forms }))
                        )
                      );

                      const sub = forkJoin(checks$).subscribe(results => {
                        this.wheelItems = results.map(({ pokemon, forms }) => {
                          if (forms.length > 0) this.hasAvailableMegaEvolutions = true;
                          return { text: pokemon.text, weight: 1, color: '#222' };
                        });
                      });

                      this.subscriptions.push(sub);
                    }

                    async onPokemonSelected(winningNumber: number): Promise<void> {
                      if (!this.pokemons?.length) return;

                      const snapshotPokemons = [...this.pokemons];
                      const selectedPokemon = snapshotPokemons[winningNumber - 1];
                      if (!selectedPokemon) return;

                      const sub = this.megaEvolutionService.getAvailableMegaFormsForPokemon(selectedPokemon).subscribe(async (forms) => {
                        if (!forms?.length) return;

                        const chosenForm = this.megaEvolutionService.chooseMegaFormForPokemon(selectedPokemon, forms);
                        if (!chosenForm) return;

                        const updated = this.applyMegaEvolution(snapshotPokemons, winningNumber, chosenForm);

                        this.typeClass = await this.getTypeClassForApiName(this.popupAfterApiName || chosenForm.apiName || selectedPokemon.text);

                        this.openMegaPopupAndProceed(updated);
                      });

                      this.subscriptions.push(sub);
                    }

                    private openMegaPopupAndProceed(updatedPokemons: PokemonItem[]): void {
                      this.popupMessage = 'megaEvolution.popupMessage';

                      this.modalRef = this.modalService.open(this.megaPopup, {
                        centered: true,
                        backdrop: 'static',
                        keyboard: false
                      });

                      this.modalRef.result.finally(() => {
                        this.isMegaAnimating = false;
                        this.stopCry();
                        this.clearTimers();
                      }).catch(() => {});

                      this.isMegaAnimating = true;

                      this.playMegaEvolutionSfx();

                      this.timers.push(window.setTimeout(() => {
                        this.playCryForMega(this.popupAfterApiName, this.popupAfterName);
                      }, 900));

                      this.timers.push(window.setTimeout(() => {
                        this.isMegaAnimating = false;
                        try { this.modalRef?.close(); } catch {}
                        this.megaEvolutionEvent.emit(updatedPokemons);
                      }, 2000));
                    }

                    private applyMegaEvolution(pokemons: PokemonItem[], winningNumber: number, megaForm: MegaForm): PokemonItem[] {
                      const pokemon = pokemons[winningNumber - 1];

                      this.popupBeforeName = pokemon.text;
                      this.popupBeforeSpriteUrl = this.pokemonService.getPokemonImage(pokemon.pokemonId);

                      const megaPokemon: PokemonItem = {
                        ...pokemon,
                        pokemonId: megaForm.id,
                        text: megaForm.displayName,
                        isMega: true,
                        megaBasePokemonId: pokemon.pokemonId,
                        megaFormName: megaForm.apiName
                      };

                      pokemons[winningNumber - 1] = megaPokemon;

                      this.popupAfterName = megaPokemon.text;
                      this.popupAfterSpriteUrl = this.pokemonService.getPokemonImage(megaPokemon.pokemonId);
                      this.popupAfterApiName = megaForm.apiName;

                      this.gameModeService.lootPokemon(megaPokemon);

                      return pokemons;
                    }

                    private playMegaEvolutionSfx(): void {
                      try {
                        if (!this.audioCtx) {
                          this.audioCtx = new (window.AudioContext || (window as any).webkitAudioContext)();
                        }
                        const ctx = this.audioCtx;
                        if (ctx.state === 'suspended') ctx.resume().catch(() => {});

                        const now = ctx.currentTime;

                        const osc = ctx.createOscillator();
                        osc.type = 'sawtooth';
                        osc.frequency.setValueAtTime(220, now);
                        osc.frequency.exponentialRampToValueAtTime(1200, now + 0.55);

                        const gain = ctx.createGain();
                        gain.gain.setValueAtTime(0.0001, now);
                        gain.gain.exponentialRampToValueAtTime(0.16, now + 0.08);
                        gain.gain.exponentialRampToValueAtTime(0.0001, now + 0.75);

                        const bufferSize = Math.floor(ctx.sampleRate * 0.5);
                        const noiseBuffer = ctx.createBuffer(1, bufferSize, ctx.sampleRate);
                        const out = noiseBuffer.getChannelData(0);
                        for (let i = 0; i < bufferSize; i++) out[i] = (Math.random() * 2 - 1) * (1 - i / bufferSize);

                        const noise = ctx.createBufferSource();
                        noise.buffer = noiseBuffer;

                        const bandpass = ctx.createBiquadFilter();
                        bandpass.type = 'bandpass';
                        bandpass.frequency.setValueAtTime(800, now);
                        bandpass.frequency.linearRampToValueAtTime(1400, now + 0.4);

                        const noiseGain = ctx.createGain();
                        noiseGain.gain.setValueAtTime(0.0001, now);
                        noiseGain.gain.exponentialRampToValueAtTime(0.12, now + 0.08);
                        noiseGain.gain.exponentialRampToValueAtTime(0.0001, now + 0.55);

                        osc.connect(gain);
                        noise.connect(bandpass);
                        bandpass.connect(noiseGain);

                        gain.connect(ctx.destination);
                        noiseGain.connect(ctx.destination);

                        osc.start(now);
                        noise.start(now);

                        osc.stop(now + 0.8);
                        noise.stop(now + 0.6);
                      } catch {}
                    }

                    private playCryForMega(apiName: string, fallbackName: string): void {
                      const cryId = this.toShowdownCryId(apiName || fallbackName);
                      const url = `https://play.pokemonshowdown.com/audio/cries/${cryId}.mp3`;

                      this.stopCry();

                      const audio = new Audio();
                      audio.preload = 'auto';
                      audio.src = url;
                      audio.volume = 0.9;

                      audio.onerror = () => {
                        const base = cryId.split('-mega')[0];
                        if (base && base !== cryId) {
                          audio.src = `https://play.pokemonshowdown.com/audio/cries/${base}.mp3`;
                          audio.play().catch(() => {});
                        }
                      };

                      audio.play().catch(() => {});
                      this.cryAudio = audio;
                    }

                    private stopCry(): void {
                      if (this.cryAudio) {
                        try {
                          this.cryAudio.pause();
                          this.cryAudio.currentTime = 0;
                        } catch {}
                      }
                      this.cryAudio = undefined;
                    }

                    private cleanupAudio(): void {
                      this.stopCry();
                      if (this.audioCtx) {
                        try { this.audioCtx.close(); } catch {}
                      }
                      this.audioCtx = undefined;
                    }

                    private clearTimers(): void {
                      this.timers.forEach(t => clearTimeout(t));
                      this.timers = [];
                    }

                    private async getTypeClassForApiName(nameOrApi: string): Promise<string> {
                      const type = await this.getPrimaryType(nameOrApi);
                      return `type-${(type || 'Normal').toLowerCase()}`;
                    }

                    private async getPrimaryType(nameOrApi: string): Promise<string> {
                      try {
                        const dex = await this.getShowdownDex();
                        const toId = (s: string) => (s || '').toLowerCase().replace(/[^a-z0-9]+/g, '');

                        const candidates = [
                          toId(nameOrApi),
                          toId(this.toShowdownCryId(nameOrApi)),
                        ];

                        for (const id of candidates) {
                          const entry = dex[id];
                          const t = entry?.types?.[0];
                          if (t) return t;
                        }
                      } catch {}
                      return 'Normal';
                    }

                    private async getShowdownDex(): Promise<Record<string, ShowdownPokedexEntry>> {
                      if (!MegaEvolutionRouletteComponent.showdownDexPromise) {
                        MegaEvolutionRouletteComponent.showdownDexPromise =
                          fetch('https://play.pokemonshowdown.com/data/pokedex.json').then(r => r.json());
                      }
                      return MegaEvolutionRouletteComponent.showdownDexPromise;
                    }

                    private toShowdownCryId(nameOrApi: string): string {
                      let s = (nameOrApi || '').trim().toLowerCase();

                      if (s.startsWith('mega ')) {
                        s = s.replace(/^mega\\s+/, '').trim();
                        const parts = s.split(/\\s+/).filter(Boolean);
                        const last = parts[parts.length - 1];
                        if (last === 'x' || last === 'y') {
                          s = `${parts.slice(0, -1).join('-')}-mega${last}`;
                        } else {
                          s = `${parts.join('-')}-mega`;
                        }
                      } else {
                        s = s.replace(/\\s+/g, '-');
                        s = s.replace(/-mega-x\\b/g, '-megax').replace(/-mega-y\\b/g, '-megay');
                      }

                      s = s.replace(/[^a-z0-9\\-]/g, '');
                      return s;
                    }
                  }
              """).lstrip()
              mega_ts.write_text(ts_src, encoding="utf-8")

          if mega_html.exists():
              html_src = textwrap.dedent("""\
                  <div *ngIf="isLoading" class="loading">
                    <p>{{ 'loading' | translate }}</p>
                  </div>

                  <div *ngIf="!isLoading && !hasAvailableMegaEvolutions" class="subtitle">
                    <p>{{ 'megaEvolution.noAvailableMegaEvolutions' | translate }}</p>
                  </div>

                  <div *ngIf="!isLoading && hasAvailableMegaEvolutions">
                    <app-wheel
                      [items]="wheelItems"
                      (selectedItemEvent)="onPokemonSelected($event)">
                    </app-wheel>
                  </div>

                  <ng-template #megaPopup let-modal>
                    <div class="modal-header">
                      <h4 class="modal-title popup-title">{{ popupTitle | translate }}</h4>
                    </div>

                    <div class="modal-body">
                      <p class="subtitle">{{ popupMessage | translate }}</p>

                      <div class="evo-wrap" [ngClass]="[typeClass, isMegaAnimating ? 'animating' : '']">
                        <div class="particles" aria-hidden="true"></div>

                        <div class="evolution-stage">
                          <img class="sprite sprite-before" [src]="popupBeforeSpriteUrl" [alt]="popupBeforeName" />
                          <img class="sprite sprite-after" [src]="popupAfterSpriteUrl" [alt]="popupAfterName" />
                        </div>

                        <div class="name-row">
                          <div class="name">{{ popupBeforeName }}</div>
                          <div class="arrow" aria-hidden="true">â†’</div>
                          <div class="name">{{ popupAfterName }}</div>
                        </div>
                      </div>

                      <div class="actions">
                        <button class="btn btn-dark" (click)="modal.close()">{{ 'ok' | translate }}</button>
                      </div>
                    </div>
                  </ng-template>
              """).lstrip()
              mega_html.write_text(html_src, encoding="utf-8")

          if mega_css.exists():
              css_src = textwrap.dedent("""\
                  .loading{text-align:center;margin-top:1rem}
                  .subtitle{text-align:center;opacity:.9;margin-bottom:.75rem}
                  .popup-title{text-align:center;margin-bottom:0}
                  .actions{display:flex;justify-content:center;margin-top:1rem}

                  .evo-wrap{display:flex;flex-direction:column;align-items:center;gap:.75rem;position:relative}
                  .evolution-stage{position:relative;width:11rem;height:11rem;display:flex;align-items:center;justify-content:center}
                  .sprite{position:absolute;width:11rem;height:11rem;object-fit:contain;will-change:transform,opacity,filter}
                  .sprite-after{opacity:0;transform:scale(.92);filter:brightness(1.2) drop-shadow(0 0 .35rem rgba(255,255,255,.35))}

                  .name-row{display:flex;align-items:center;justify-content:center;gap:.75rem;flex-wrap:wrap}
                  .name{min-width:6.5rem;text-align:center;font-weight:700}
                  .arrow{font-size:1.6rem;opacity:.85}

                  .particles{position:absolute;inset:-10%;pointer-events:none;overflow:hidden;border-radius:999px}
                  .particles::before{content:'';position:absolute;inset:0;opacity:0;transform:translateY(15%);will-change:transform,opacity,filter}

                  .animating .sprite-before{animation:megaBefore .85s ease-in-out forwards}
                  .animating .sprite-after{animation:megaAfter .85s ease-in-out forwards}
                  .animating .particles::before{opacity:1;animation:particleMove .9s ease-out forwards}

                  @keyframes megaBefore{
                    0%{opacity:1;transform:scale(1);filter:brightness(1)}
                    45%{opacity:1;transform:scale(1.02);filter:brightness(1.7)}
                    100%{opacity:0;transform:scale(1.1);filter:brightness(1.2) blur(2px)}
                  }
                  @keyframes megaAfter{
                    0%{opacity:0;transform:scale(.92);filter:brightness(2.2) blur(2px)}
                    60%{opacity:1;transform:scale(1.06);filter:brightness(1.25)}
                    100%{opacity:1;transform:scale(1);filter:brightness(1.05)}
                  }
                  @keyframes particleMove{
                    from{transform:translateY(18%) scale(.98);filter:blur(0)}
                    to{transform:translateY(-20%) scale(1.02);filter:blur(.4px)}
                  }

                  .type-water .particles::before{
                    background-image:
                      radial-gradient(circle at 15% 80%, rgba(200,240,255,.95) 0 2px, transparent 3px),
                      radial-gradient(circle at 45% 90%, rgba(200,240,255,.95) 0 3px, transparent 4px),
                      radial-gradient(circle at 75% 85%, rgba(200,240,255,.95) 0 2px, transparent 3px),
                      radial-gradient(circle at 35% 60%, rgba(200,240,255,.75) 0 2px, transparent 3px),
                      radial-gradient(circle at 65% 70%, rgba(200,240,255,.75) 0 3px, transparent 4px);
                    background-size:24px 24px;
                  }
                  .type-fire .particles::before{
                    background-image:
                      radial-gradient(circle at 20% 80%, rgba(255,190,120,.95) 0 2px, transparent 3px),
                      radial-gradient(circle at 55% 90%, rgba(255,150,90,.9) 0 3px, transparent 4px),
                      radial-gradient(circle at 80% 85%, rgba(255,210,140,.9) 0 2px, transparent 3px);
                    background-size:22px 22px;
                  }
                  .type-electric .particles::before{
                    background-image:
                      linear-gradient(135deg, transparent 45%, rgba(255,255,160,.85) 46%, rgba(255,255,160,.85) 54%, transparent 55%),
                      linear-gradient(45deg, transparent 45%, rgba(255,255,160,.75) 46%, rgba(255,255,160,.75) 54%, transparent 55%);
                    background-size:28px 28px;
                    mix-blend-mode:screen;
                  }
              """).lstrip()
              mega_css.write_text(css_src, encoding="utf-8")

          print("Patch OK (YAML-safe).")
          PY

      - name: Build (relative paths for GitHub Pages)
        working-directory: ${{ env.PROJECT_ROOT }}
        env:
          NODE_OPTIONS: --max_old_space_size=4096
        run: npm run build -- --configuration production --base-href "./" --deploy-url "./"

      - name: Locate index.html for Pages
        run: |
          set -e
          IDX="$(find "${{ env.PROJECT_ROOT }}/dist" -maxdepth 12 -type f -name index.html -print -quit)"
          if [ -z "$IDX" ]; then
            echo "ERROR: index.html not found in dist."
            exit 1
          fi
          PAGES_DIR="$(dirname "$IDX")"
          echo "PAGES_PATH=$PAGES_DIR" >> $GITHUB_ENV
          touch "$PAGES_DIR/.nojekyll"

      - name: Upload Pages artifact
        uses: actions/upload-pages-artifact@v3
        with:
          path: ${{ env.PAGES_PATH }}

  deploy:
    needs: build
    runs-on: ubuntu-latest
    environment:
      name: github-pages
      url: ${{ steps.deployment.outputs.page_url }}
    steps:
      - name: Deploy to GitHub Pages
        id: deployment
        uses: actions/deploy-pages@v4
